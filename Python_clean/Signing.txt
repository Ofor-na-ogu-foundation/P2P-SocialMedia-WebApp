Digital Signatures
You can use a digital signature for many of the same reasons that you might sign a paper document. A valid digital signature gives a recipient reason to believe that the message was created by a known sender such that they cannot deny sending it (authentication and non-repudiation) and that the message was not altered in transit (integrity).

Digital signatures allow you to publish a public key, and then you can use your private signing key to sign messages. Others who have your public key can then use it to validate that your messages are actually authentic.

Example
Signer’s perspective (SigningKey)

import nacl.encoding
import nacl.signing

# Generate a new random signing key
signing_key = nacl.signing.SigningKey.generate()

# Sign a message with the signing key
signed = signing_key.sign(b"Attack at Dawn")

# Obtain the verify key for a given signing key
verify_key = signing_key.verify_key

# Serialize the verify key to send it to a third party
verify_key_hex = verify_key.encode(encoder=nacl.encoding.HexEncoder)
Verifier’s perspective (VerifyKey)

import nacl.signing

# Create a VerifyKey object from a hex serialized public key
verify_key = nacl.signing.VerifyKey(verify_key_hex,
                                    encoder=nacl.encoding.HexEncoder)

# Check the validity of a message's signature
# The message and the signature can either be passed separately or
# concatenated together.  These are equivalent:
verify_key.verify(signed)
verify_key.verify(signed.message, signed.signature)

# Alter the signed message text
forged = signed[:-1] + bytes([int(signed[-1]) ^ 1])
# Will raise nacl.exceptions.BadSignatureError, since the signature check
# is failing
verify_key.verify(forged)
Traceback (most recent call last):
 ...
nacl.exceptions.BadSignatureError: Signature was forged or corrupt
Reference
class nacl.signing.SigningKey(seed, encoder)[source]
Private key for producing digital signatures using the Ed25519 algorithm.

Signing keys are produced from a 32-byte (256-bit) random seed value. This value can be passed into the SigningKey as a bytes() whose length is 32.

Warning

This must be protected and remain secret. Anyone who knows the value of your SigningKey or its seed can masquerade as you.

Parameters:	
seed (bytes) – Random 32-byte value (i.e. private key).
encoder – A class that is able to decode the seed.
verify_key
An instance of VerifyKey (i.e. public key) that corresponds with the signing key.

classmethod generate()[source]
Generates a random SigningKey object

Returns:	An instance of SigningKey.
sign(message, encoder)[source]
Sign a message using this key.

Parameters:	
message (bytes) – The data to be signed.
encoder – A class that is able to decode the signed message.
Returns:	
An instance of SignedMessage.

class nacl.signing.VerifyKey(key, encoder)[source]
The public key counterpart to an Ed25519 SigningKey for producing digital signatures.

Parameters:	
key (bytes) – A serialized Ed25519 public key.
encoder – A class that is able to decode the key.
verify(smessage, signature, encoder)[source]
Verifies the signature of a signed message.

Parameters:	
smessage (bytes) – The signed message to verify. This is either the original message or the concated signature and message.
signature (bytes) – The signature of the message to verify against. If the value of smessage is the concated signature and message, this parameter can be None.
encoder – A class that is able to decode the secret message and signature.
Return bytes:	
The message if successfully verified.

Raises:	
nacl.exceptions.BadSignatureError – This is raised if the signature is invalid.

class nacl.signing.SignedMessage[source]
A bytes subclass that holds a messaged that has been signed by a SigningKey.

signature
The signature contained within the SignedMessage.

message
The message contained within the SignedMessage.
